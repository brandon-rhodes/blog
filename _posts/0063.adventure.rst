---
categories: Python, Computing
date: 2012/04/05 18:09:25
permalink: http://rhodesmill.org/brandon/2012/adventure/
tags: ''
title: Adventure in Python 3
---

I have just released
`adventure 1.2 <http://pypi.python.org/pypi/adventure/1.2/>`_
on the Python Package Index,
an update of my Python 3 port
of the original Colossal Cave Adventure game
that I announced last year during the final round of
`PyCon 2011 lightning talks <http://pyvideo.org/video/357/pycon-2011--sunday-afternoon-lightning-talks>`_.

.. image:: http://rhodesmill.org/brandon/2012/adventure-heathkit-h19.jpg
   :target: http://www.flickr.com/photos/brandonrhodes/6115627693/

Written in the late 1970s,
“Adventure” was the first game
to offer players a virtual world to explore at their own pace,
driven by their own curiosity.
The player directs the game with simple one- and two-word commands
like ``ENTER`` ``BUILDING`` and ``GET`` ``LAMP``,
together with the cardinal directions —
which could, mercifully, be typed as abbreviations
(``N``, ``NE``, ``E``, ``SE``, and so forth,
with ``U`` and ``D`` for up and down).
Based on a real-life section
of the Flint-Mammoth cave system in Kentucky
that the author helped map,
“Adventure” invites you to start collecting treasures from the cave
in a quest that eventually involves danger, magic,
and even encounters with a few computer-controlled characters,
who rustle in the darkness beyond the range of your lamp
before finally pouncing.

Keep reading if you want to learn
about several discoveries that I made
while porting “Adventure” to Python!
If you want to know more about the history of the original game itself,
I recommend Dennis G. Jerz's admirably thorough paper
“`Somewhere Nearby is Colossal Cave: Examining Will Crowther's Original ‘Adventure’ in Code and in Kentucky <http://www.digitalhumanities.org/dhq/vol/001/2/000009/000009.html>`_”
from the Summer 2007 issue of the Digital Humanities Quarterly.

.. more

Playing at the prompt
---------------------

I was inspired to write the ``adventure`` package
when I realized that typing a name at the Python prompt
could invoke an action if the object it referenced
did something useful inside of its ``__repr__()`` method.

Recall that a language like Ruby invokes a function
if you merely mention the function's name::

    #!ruby
    jump    # call the "jump" function in Ruby

I imagine that this would make it easy
to implement a game like Adventure at the Ruby prompt.
Typing the name of a command like ``jump`` or ``n`` or ``sw``
would simply invoke it, just like at the prompt of the original game.

In Python, however —
as in higher math more generally,
whose scruples Python tends to honor more faithfully
than do other popular languages —
``jump`` is merely a name,
and its mention merely retrieves a reference to the function it names.
To actually invoke the function you need to follow the name
with a pair of parentheses::

    #!python
    jump()    # call the "jump" function in Python

For more information about this distinction,
see the discussion between Alice and the Red Knight
about songs and names-of-songs in
`Chapter VIII <http://en.wikisource.org/wiki/Through_the_Looking-Glass,_and_What_Alice_Found_There/Chapter_VIII>`_
of *Through the Looking Glass*
— remember that Lewis Carroll was a logician in his day job! —
or, if you find his writing far too tedious and “cute,”
start at the Wikipedia article on the
`use-mention distinction <http://en.wikipedia.org/wiki/Use%E2%80%93mention_distinction>`_.
And tell any analytic philosophers you know
that Python is your favorite programming language.

So the following line of Python code by definition does nothing,
except, perhaps — depending on which implementation of Python you use —
innocently incrementing and then decrementing
the ``jump`` object's reference count::

    #!python
    jump    # fetches then discards a reference

But things are quite different if,
instead of appearing in a script on a line by itself,
the bare name is typed at the interactive Python prompt,
because the third action taken by the prompt's read-eval-print loop —
the “print” action —
invokes the object's ``__repr__()`` method.
For a normal function this simply makes it describe itself::

    #!python
    >>> max
    <built-in function max>

But if we write a class of our own,
we can do arbitrarily complex work when ``__repr__()`` is called! ::

 #!python
 >>> class C(object):
 ...     def __repr__(self):
 ...         print('[advancing the game state]')
 ...         return 'There is a shiny brass lamp nearby.'
 ...
 >>> jump = C()

We now have an object that, when simply named,
causes something to happen and then returns a message
that Python displays to show us the result. ::

 #!python
 >>> c
 [advancing the game state]
 There is a shiny brass lamp nearby.

And this is what the ``adventure`` package does, in spades.
When you invoke its ``play()`` function at the Python prompt,
it uses the
`inspect <http://docs.python.org/library/inspect.html>`_
Standard Library module
to reach into the scope of your Python prompt
and define every “Adventure” game word as a symbol
whose ``__repr__()`` is sitting ready to be triggered.

The word objects are also supplied with other methods
like ``__call__()`` and ``__getattr__()``
so that words can be composed to form more complex commands,
like ``get(lamp)`` or the equivalent ``get.lamp`` —
see
`prompt.py <https://bitbucket.org/brandon/adventure/src/86507c6fe2b9/adventure/prompt.py>`_
if you want to read all of the details.

De Morgan and old FORTRAN
-------------------------

The original FORTRAN language
in which “Adventure” is written
does not support “structured programming” —
you cannot combine several statements into a single block of code
under the control of an ``IF`` statement.
Instead, ``IF`` can only govern
the single statement that follows it.
Several statements can be controlled by ``IF``
only by pointing a ``GOTO`` at the first statement that follows them.
Here, for example, is an excerpt from ``advent.for``
in which an ``IF`` clause controls two statements,
with normal execution continuing at line ``2630``::

 #!fortran
 2610    IF(WD1.NE.'WEST')GOTO 2630
         IWEST=IWEST+1
         IF(IWEST.EQ.10)CALL RSPEAK(17)
 2630

In Python, the line number and ``GOTO`` disappear
in favor of simply indenting the lines that run conditionally::

            #!python
            if word1 == 'west':
                full_wests += 1
                if full_wests == 10:
                    write_message(17)

You will note that my outer Python ``if`` statement
tests a condition that is, in fact, the complete *opposite*
of its equivalent in FORTRAN:
the original code wants the word to not-equal ``'WEST'``
whereas, in my rewrite, I test whether they are equal.
The reason is plain enough:
while my modern Python code gets to directly test
whether to execute the block of code,
the original FORTRAN has to think backwards
and test whether to *skip* the statements that follow.

(Note that the second ``IF`` statement
controls only a single line of code,
and therefore is written “forwards” even in FORTRAN.)

Flipping a simple ``.NE.`` so that it becomes ``==`` is simple enough.
But what happens when I need to
`reverse the polarity <http://en.wikipedia.org/wiki/Third_Doctor#.22Reverse_the_polarity.22>`_
of a more complex expression? ::

 #!fortran
         IF((WD1.NE.'WATER'.AND.WD1.NE.'OIL')
         1	.OR.(WD2.NE.'PLANT'.AND.WD2.NE.'DOOR'))GOTO 2610
         IF(AT(VOCAB(WD2,1)))WD2='POUR'
 2610

I was delighted!
Here — *finally* — was a use for De Morgan's laws,
a mere seventeen years after I learned them in computer science class!

`De Morgan's laws <http://en.wikipedia.org/wiki/De_Morgan's_laws>`_
state, basically,
that instead of simply slapping ``not`` in front of a large expression —
and thereby making your code even less easy to reason about —
you can dive into the big expression changing ``and`` to ``or``,
``or`` to ``and``,
and reversing the meaning of each equality.
The expression that results will mean precisely the opposite.
You do have to be careful with parentheses
since ``and`` and ``or`` have different precedence
in most programming languages,
but De Morgan let me convert the FORTRAN above
into roughly this Python translation::

        #!python
        if ((word1 == 'water' or word1 == 'oil') and
            (word2 == 'plant' or word2 == 'door') and
            self.is_here(self.referent(word2))):
            ...

In general, much of the work
of translating “Adventure” to Python
involved taking FORTRAN code that said one thing
and making it say more or less exactly the opposite,
so that I could replace ``GOTO`` statements
with more modern — and more readable — control flow.

Testing randomness is tricky
----------------------------

The main tests for the game are two large walkthroughs.
You can find them in the package's ``tests`` directory.
Since the game is playable at the Python prompt,
each walkthrough is simply a long docfile
that starts the game and plays to completion.
I pass them to a Standard Library
`DocFileSuite <http://docs.python.org/library/doctest.html#doctest.DocFileSuite>`_
and away they go.

As soon as I started implementing game elements
that involved chance, my tests started breaking,
because the series of numbers from the
`random <http://docs.python.org/library/random.html>`_
Standard Library module is different every time you run Python.
So at the beginning of each test
I set the ``random`` generator's seed value,
making the sequence of pseudo-random numbers
unfold in the same order every time.
In case anyone runs my tests in parallel,
I even abandoned the global random number generator
and gave each instance of my ``Game`` class
its own ``Random()`` object,
so that two games going at once
will not interfere with each other's stream of random numbers.
So each walkthrough starts with something like::

 >>> import adventure
 >>> adventure.play(seed=2)
 WELCOME TO ADVENTURE!!  WOULD YOU LIKE INSTRUCTIONS?
 <BLANKLINE>
 >>> no

After all of that caution, I felt betrayed and dismayed
when the tests *still* wound up being random,
giving different output every time they were run!

It took me quite a long time to realize
that my problem was this scrap of code::

    #!python
    locations = {
        # every room reachable from here
        }
    next_room = self.random.choice(locations)

Why is this code a problem?
Well, to choose an item from a set ``s``,
``choice()`` selects an integer ``0`` ``≤`` ``n`` ``<`` ``len(s)``
and iterates over ``n`` items to find item number ``n``.
Sets, by definition, have no inherent ordering.
When faced with quite generic objects like my ``Room`` instances,
the set hashes and stores them by their memory address.
And — why did it take me several hours to remember this? —
Python object memory address are not stable
from one run of the interpreter to another
even if you are running *exactly* the same code!

So the random number generator
would indeed return a stable value — for example, 3 —
but iterating across ``locations`` would yield a different
“object 3” each time I ran my tests.

The worse part was that these random room decisions were hidden —
their consequences were not immediately visible to the player —
so the walkthrough would not fail until much later,
when the code snippet above was long past.
I kept staring at the code at the point of failure,
not at all suspecting that the random number generator
was being knocked off course invisibly
a hundred lines earlier in the walkthrough!

Great experiences at 1200 baud
------------------------------

My final discovery was made quite by accident.
Now that 
