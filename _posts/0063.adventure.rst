---
categories: Python, Computing
date: 2012/04/05 18:09:25
permalink: http://rhodesmill.org/brandon/2012/adventure/
tags: ''
title: Adventure in Python 3
---

I have just released
`adventure 1.2 <http://pypi.python.org/pypi/adventure/>`_
on the Python Package Index,
an update of my Python 3 port
of the original Colossal Cave Adventure game
that I announced last year during the final round of
`PyCon 2011 lightning talks <http://pyvideo.org/video/357/pycon-2011--sunday-afternoon-lightning-talks>`_.

.. image:: http://rhodesmill.org/brandon/2012/adventure-heathkit-h19.jpg
   :target: http://www.flickr.com/photos/brandonrhodes/6115627693/

Released in the late 1970s,
“Adventure” was the first game
to offer players a virtual world to explore at their own pace,
driven by their own curiosity.
The player directs the game with simple one- and two-word commands
like ``ENTER`` ``BUILDING`` and ``GET`` ``LAMP``,
together with the cardinal directions —
which could, mercifully, be typed as abbreviations
(``N``, ``NE``, ``E``, ``SE``, and so forth,
with ``U`` and ``D`` for up and down).
Based on a real-life section
of the Flint-Mammoth cave system in Kentucky
that the author helped map,
“Adventure” invites you to start collecting treasures from the cave
in a quest that eventually involves danger, magic,
and even encounters with a few computer-controlled characters,
who rustle in the darkness beyond the range of your lamp
before finally pouncing.

Keep reading if you want to learn
about several discoveries that I made
while porting “Adventure” to Python!
If you want to know more about the history of the original game itself,
I recommend Dennis G. Jerz's admirably thorough paper
“`Somewhere Nearby is Colossal Cave: Examining Will Crowther's Original ‘Adventure’ in Code and in Kentucky <http://www.digitalhumanities.org/dhq/vol/001/2/000009/000009.html>`_”
from the Summer 2007 issue of the Digital Humanities Quarterly.

.. more

Playing at the prompt
---------------------

first lesson python can respond to single-word commands

easy to respond to two-word commands

just had to inject symbols into calling context

so they can say .play() and the game can begin

but one-word commands do no call
simply naming a function does not invoke it
unlike Ruby where you have to do a dance to get a ref to a function

so I overrode __repr__

De Morgan and old FORTRAN
-------------------------

The original FORTRAN language
in which “Adventure” is written
does not support “structured programming” —
you cannot combine several statements into a single block of code
under the control of an ``IF`` statement.
Instead, ``IF`` can only govern
the single statement that follows it.
Several statements can be controlled by ``IF``
only by pointing a ``GOTO`` at the first statement that follows them.
Here, for example, is an excerpt from ``advent.for``
in which an ``IF`` clause controls two statements,
with normal execution continuing at line ``2630``::

 #!fortran
 2610    IF(WD1.NE.'WEST')GOTO 2630
         IWEST=IWEST+1
         IF(IWEST.EQ.10)CALL RSPEAK(17)
 2630

In Python, the line number and ``GOTO`` disappear
in favor of simply indenting the lines that run conditionally::

            #!python
            if word1 == 'west':
                full_wests += 1
                if full_wests == 10:
                    write_message(17)

You will note that my outer Python ``if`` statement
tests a condition that is, in fact, the complete *opposite*
of its equivalent in FORTRAN:
the original code wants the word to not-equal ``'WEST'``
whereas, in my rewrite, I test whether they are equal.
The reason is plain enough:
while my modern Python code gets to directly test
whether to execute the block of code,
the original FORTRAN has to think backwards
and test whether to *skip* the statements that follow.

(Note that the second ``IF`` statement
controls only a single line of code,
and therefore is written “forwards” even in FORTRAN.)

Flipping a simple ``.NE.`` so that it becomes ``==`` is simple enough.
But what happens when I need to
`reverse the polarity <http://en.wikipedia.org/wiki/Third_Doctor#.22Reverse_the_polarity.22>`_
of a more complex expression? ::

 #!fortran
         IF((WD1.NE.'WATER'.AND.WD1.NE.'OIL')
         1	.OR.(WD2.NE.'PLANT'.AND.WD2.NE.'DOOR'))GOTO 2610
         IF(AT(VOCAB(WD2,1)))WD2='POUR'
 2610

I was delighted!
Here — *finally* — was a use for De Morgan's laws,
a mere seventeen years after I learned them in computer science class!

`De Morgan's laws <http://en.wikipedia.org/wiki/De_Morgan's_laws>`_
state, basically,
that instead of simply slapping ``not`` in front of a large expression —
and thereby making your code even less easy to reason about —
you can dive into the big expression changing ``and`` to ``or``,
``or`` to ``and``,
and reversing the meaning of each equality.
The expression that results will mean precisely the opposite.
You do have to be careful with parentheses
since ``and`` and ``or`` have different precedence
in most programming languages,
but De Morgan let me convert the FORTRAN above
into roughly this Python translation::

        #!python
        if ((word1 == 'water' or word1 == 'oil') and
            (word2 == 'plant' or word2 == 'door') and
            self.is_here(self.referent(word2))):
            ...

In general, much of the work
of translating “Adventure” to Python
involved taking FORTRAN code that said one thing
and making it say more or less exactly the opposite,
so that I could replace ``GOTO`` statements
with more modern — and more readable — control flow.

Great experiences at 1200 baud
------------------------------


