---
categories: Python, Computing
date: 2012/04/11 00:00:00
permalink: http://rhodesmill.org/brandon/2012/logging_tree/
tags: ''
title: Introspect Python logging with logging_tree
---

It is frustrating that Python's ``logging`` module
cannot display the tangled tree of configured loggers
that can result from combining your own application code
with several libraries and frameworks.
So I have released a new Python package named
`logging_tree <http://pypi.python.org/pypi/logging_tree>`_,
which I announced last month during the
`PyCon 2012 <https://us.pycon.org/2012/>`_
`closing lightning talks <http://pyvideo.org/video/721/sunday-afternoon-lightning-talks-90-minutes>`_.
The ``logging_tree`` package displays the current ``logging`` tree
to help your debugging.
Its output looks like this::

    <--""
       Level WARNING
       Handler Stream <open file '<stderr>', mode 'w' at…>
       |
       o<--[cherrypy]
           |
           o<--"cherrypy.access"
           |   Level INFO
           |   Handler Stream <open file '<stdout>', mode 'w'…>
           |
           o<--"cherrypy.error"
               Level INFO
               Handler Stream <open file '<stderr>', mode 'w'…>

The configuration shown by this tree, it turns out, causes a bug.
This diagram helped me fix a real-life application
for Atlanta startup `Rover Apps <http://roverapps.com/>`_,
who generously let me open-source ``logging_tree``
after I wrote the first version
to help them manage the ``logging`` module's behavior.

In this post I am going to reproduce the problem
using a simple 10-line CherryPy application,
and then show how I used this ``logging_tree`` diagram
to solve our problem.
But, first, you need to know three things
about the Python ``logging`` module:

.. more

* Logging messages propagate up the tree by default,
  even if they have already been logged by a handler!
  The only thing that can stop propagation
  is making a logger's ``propagate`` attribute false,
  instead of the default value of true.
  So a message written to logger ``a.b.c`` will
  also propagate to ``'a.b'``, ``'a'``,
  and finally the root logger named ``''`` (the empty string).

* When a logger considers a message,
  it checks the message's level against its own ``level``
  (or that of the nearest parent to specify one)
  and prints it using its handlers
  if the message is at least that important.

* Confusingly, handlers themselves can *also* have levels,
  which give messages a second chance to be thrown out as unimportant;
  and handlers can even hand messages off to further handlers.

Some libraries also define custom filters and handlers.
While ``logging_tree`` will at least print their names,
it probably will not know anything else about them,
so you will have to read their source code
to learn more about how they work and behave.

The problem
-----------

We wanted to add some logging of our own to our CherryPy application,
so — as a simple first step — we grabbed the root logger ``''``
and tried writing a message::

    #!python
    import cherrypy
    import logging

    log = logging.getLogger('')

    class HelloWorld:
        def index(self):
            log.error('Test message')
            return 'Hello world!'
        index.exposed = True

    if __name__ == '__main__':
        cherrypy.quickstart(HelloWorld())

The result was disappointing.
The site displayed ``Hello`` ``world!`` in the browser
and produced a standard Apache log message,
but our own log message was nowhere to be seen.
I knew enough about ``logging`` to know that
“handlers” were necessary if I wanted log messages to be output,
so I tried adding a handler to the root logger::

    if __name__ == '__main__':
        log.addHandler(logging.StreamHandler())
        cherrypy.quickstart(HelloWorld())

The result was rather bizarre.
While our ``Test`` ``message`` now appeared in the output,
the server produced *two* copies of every Apache log message.


::

    import logging_tree
    logging_tree.printout()



It uses the raw standard output stream in the hope that,
even if all of the loggers are broken,
the standard output might still be connected
to the developer's terminal.


::

    logging.getLogger('cherrypy').propagate = False



::

    <--""
       Level WARNING
       Handler Stream <open file '<stderr>', mode 'w' at…>
       |
       o   "cherrypy"
           Propagate OFF
           |
           o<--"cherrypy.access"
           |   Level INFO
           |   Handler Stream <open file '<stdout>', mode 'w'…>
           |
           o<--"cherrypy.error"
               Level INFO
               Handler Stream <open file '<stderr>', mode 'w'…>

