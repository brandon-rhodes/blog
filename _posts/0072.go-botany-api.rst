---
categories: Computing Python
date: 2013/03/11 02:03:04
permalink: http://rhodesmill.org/brandon/2013/go-botany-api/
title: The Obvious API Was Dreadful
draft: true
---

Our initial approach seemed so reasonable:
identify the basic operations
that users of our web application would need to perform,
and map each operation to an HTTP resource
that the user's browser could fetch.
It turns out that this approach was dreadful,
and I would like to outline why,
in case you run into a similar situation yourself.

The project in question is Go Botany!,
an effort of the New England Wildflower Society
to help students, teachers, and amateur botanists identify plants.
It has been my great honor as a consulting programmer
to have helped them build the site over almost three years.
[link to github showing and crediting other contributors]

The idea of Go Botany is to support a free-wheeling search process
in which the user provides more and more information about the plant
that they have found, and the application successively narrows the
remaining options by removing non-matches from the screen.

that forces the user to answer questions in a set order

in their communities, in state parks,
and in their own back yards.

Our first assay
---------------

(is assay a word? and is it the RIGHT word?)

The user narrows down the options.

    /taxon/?flower_color=blue&leaf=lobed

code called looks like

    base_query = models.Taxon.objects
    for k, v in kwargs.items():
        base_query = base_query.filter(
            character_values__character__short_name=k,
            character_values__value_str=v)

why so many relations?
because of normalization.
Character has a short name like 'flower_color'.
Several character values can be associated with it,
like 'red' and 'yellow'.
Finally, each Taxon is related through a binary relation
to all of the character values that belong to it.

[Is there a Sphinx plugin for graphviz?]

::

     Character

                        ↗
                   red             (hmm, big diagram if finished)
                 ↗
    flower_color → yellow
                 ↘
                   blue

normalization can prevent aliasing between
Without some form of normalization like sorting
URL parameters alphabetically, the same query
might get submitted - and need to be cached -
under several different names

    # Same query, different URLs

    /taxon/?flower_color=blue&leaf=lobed
    /taxon/?leaf=lobed&flower_color=blue

but assuming normalization is solved
there are still big problems

first the query is not terribly efficient.
yes we are using postgresql which will do okay.
but imagine 6 filters specified.
1 + 3 * 6 = JOIN across 19 items!
not happy.

plus it requires duplicate work.
if you have already selected 5 filters
and your front-end is showing you the matching plants,
then why recompute that result again
as part of computing the more limited set of plants
that match all six filters?

that could be remedied by having the front-end
pass in the list of plants on the board,
and asking it to be filtered.
But what would that look like when dozens or hundreds of plants
are involved? ::

    /taxon/?leaf=lobed&plants=<523 plant identifiers>

but the real problem is that the results are not effectively cacheable
by the web framework to save the cost of dynamic back-end calls.
Yes, you can turn on caching, and set caching headers.
But how likely is it that a url you have delivered
will ever be visited by another browser?

Because Go Botany lets each user take their own route,
there are thousands of possibilities for even the first three answers.
By answer three of four, the chance that two users will be following
exactly the same path becomes vanishingly small —
along with the chance that an API result that we have cached
will get delivered to another browser before finally expiring.

In short, the obvious route —
the user will use the application to ask question X,
so we should provide an API call that lets them ask X
and responds with the answer —
resulted in an API call that could easily involve
a 20-way or 30-way ``JOIN`` that,
while expensive, would also be almost useless to cache
because of the improbability of another user needing it.

Letting the browser do the work
-------------------------------

The solution was to abandon a tight coupling
between the services provided by our web API
and the application's purpose as experienced by the user.
We decided to give the API a far simpler assignment:
when the front end asked “which plants have red flowers?”
the back end would answer with a list of integers
identifying the plants that match that particular value.
A user performing the query that was mentioned earlier would
thus induce the fetching of six resources from the API::

    /vectors/character/flower_shape/
    ...

It was then a simple matter to have the front-end
compute the intersection of these lists
and display the resulting plants.
A separate API call,
that only needed to be called once at page load,
let the front-end learn which integers map to which plants.

[when was underscore.js invented? can I say "then it was invented"?]

The advantages were stunning.
Consider for a moment a resource like::

    /vectors/character/flower_shape/

To generate this resource,
the application performs a simple JOIN between three tables
which each appear exactly once in the query.

Best of all, the resource is eminently cacheable.
The URL identifies a simple and plain concept
that is not context dependent;
the same data is returned whether the user sets a flower color
early in their search, or as their very last step.
And since this resource will necessarily be pulled
by every user who ever involves flower shape in their search,
it has a quite reasonable probability
of getting re-used if placed in our cache.

How do I wrap this up?
----------------------

